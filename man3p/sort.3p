.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "sort 3p"
.TH sort 3p "2019-02-13" "perl v5.32.1" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
sort \- perl pragma to control sort() behaviour
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    use sort \*(Aqstable\*(Aq;          # guarantee stability
\&    use sort \*(Aqdefaults\*(Aq;        # revert to default behavior
\&    no  sort \*(Aqstable\*(Aq;          # stability not important
\&
\&    my $current;
\&    BEGIN {
\&        $current = sort::current();     # identify prevailing pragmata
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
With the \f(CW\*(C`sort\*(C'\fR pragma you can control the behaviour of the builtin
\&\f(CW\*(C`sort()\*(C'\fR function.
.PP
A stable sort means that for records that compare equal, the original
input ordering is preserved.
Stability will matter only if elements that compare equal can be
distinguished in some other way.  That means that simple numerical
and lexical sorts do not profit from stability, since equal elements
are indistinguishable.  However, with a comparison such as
.PP
.Vb 1
\&   { substr($a, 0, 3) cmp substr($b, 0, 3) }
.Ve
.PP
stability might matter because elements that compare equal on the
first 3 characters may be distinguished based on subsequent characters.
.PP
Whether sorting is stable by default is an accident of implementation
that can change (and has changed) between Perl versions.
If stability is important, be sure to
say so with a
.PP
.Vb 1
\&  use sort \*(Aqstable\*(Aq;
.Ve
.PP
The \f(CW\*(C`no sort\*(C'\fR pragma doesn't
\&\fIforbid\fR what follows, it just leaves the choice open.  Thus, after
.PP
.Vb 1
\&  no sort \*(Aqstable\*(Aq;
.Ve
.PP
sorting may happen to be stable anyway.
.SH "CAVEATS"
.IX Header "CAVEATS"
As of Perl 5.10, this pragma is lexically scoped and takes effect
at compile time. In earlier versions its effect was global and took
effect at run-time; the documentation suggested using \f(CW\*(C`eval()\*(C'\fR to
change the behaviour:
.PP
.Vb 10
\&  { eval \*(Aqno sort "stable"\*(Aq;      # stability not wanted
\&    print sort::current . "\en";
\&    @a = sort @b;
\&    eval \*(Aquse sort "defaults"\*(Aq;   # clean up, for others
\&  }
\&  { eval \*(Aquse sort qw(defaults stable)\*(Aq;     # force stability
\&    print sort::current . "\en";
\&    @c = sort @d;
\&    eval \*(Aquse sort "defaults"\*(Aq;   # clean up, for others
\&  }
.Ve
.PP
Such code no longer has the desired effect, for two reasons.
Firstly, the use of \f(CW\*(C`eval()\*(C'\fR means that the sorting algorithm
is not changed until runtime, by which time it's too late to
have any effect. Secondly, \f(CW\*(C`sort::current\*(C'\fR is also called at
run-time, when in fact the compile-time value of \f(CW\*(C`sort::current\*(C'\fR
is the one that matters.
.PP
So now this code would be written:
.PP
.Vb 10
\&  { no sort "stable";      # stability not wanted
\&    my $current;
\&    BEGIN { $current = sort::current; }
\&    print "$current\en";
\&    @a = sort @b;
\&    # Pragmas go out of scope at the end of the block
\&  }
\&  { use sort qw(defaults stable);     # force stability
\&    my $current;
\&    BEGIN { $current = sort::current; }
\&    print "$current\en";
\&    @c = sort @d;
\&  }
.Ve
