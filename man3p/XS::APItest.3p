.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "ext::XS-APItest::APItest 3p"
.TH ext::XS-APItest::APItest 3p "2021-03-02" "perl v5.32.1" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XS::APItest \- Test the perl C API
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use XS::APItest;
\&  print_double(4);
\&
\&  use XS::APItest qw(rpn calcrpn);
\&  $triangle = rpn($n $n 1 + * 2 /);
\&  calcrpn $triangle { $n $n 1 + * 2 / }
.Ve
.SH "ABSTRACT"
.IX Header "ABSTRACT"
This module tests the perl C \s-1API.\s0 Also exposes various bit of the perl
internals for the use of core test scripts.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module can be used to check that the perl C \s-1API\s0 is behaving
correctly. This module provides test functions and an associated
test script that verifies the output.
.PP
This module is not meant to be installed.
.SS "\s-1EXPORT\s0"
.IX Subsection "EXPORT"
Exports all the test functions:
.IP "\fBprint_double\fR" 4
.IX Item "print_double"
Test that a double-precision floating point number is formatted
correctly by \f(CW\*(C`printf\*(C'\fR.
.Sp
.Vb 1
\&  print_double( $val );
.Ve
.Sp
Output is sent to \s-1STDOUT.\s0
.IP "\fBprint_long_double\fR" 4
.IX Item "print_long_double"
Test that a \f(CW\*(C`long double\*(C'\fR is formatted correctly by
\&\f(CW\*(C`printf\*(C'\fR. Takes no arguments \- the test value is hard-wired
into the function (as \*(L"7\*(R").
.Sp
.Vb 1
\&  print_long_double();
.Ve
.Sp
Output is sent to \s-1STDOUT.\s0
.IP "\fBhave_long_double\fR" 4
.IX Item "have_long_double"
Determine whether a \f(CW\*(C`long double\*(C'\fR is supported by Perl.  This should
be used to determine whether to test \f(CW\*(C`print_long_double\*(C'\fR.
.Sp
.Vb 1
\&  print_long_double() if have_long_double;
.Ve
.IP "\fBprint_nv\fR" 4
.IX Item "print_nv"
Test that an \f(CW\*(C`NV\*(C'\fR is formatted correctly by
\&\f(CW\*(C`printf\*(C'\fR.
.Sp
.Vb 1
\&  print_nv( $val );
.Ve
.Sp
Output is sent to \s-1STDOUT.\s0
.IP "\fBprint_iv\fR" 4
.IX Item "print_iv"
Test that an \f(CW\*(C`IV\*(C'\fR is formatted correctly by
\&\f(CW\*(C`printf\*(C'\fR.
.Sp
.Vb 1
\&  print_iv( $val );
.Ve
.Sp
Output is sent to \s-1STDOUT.\s0
.IP "\fBprint_uv\fR" 4
.IX Item "print_uv"
Test that an \f(CW\*(C`UV\*(C'\fR is formatted correctly by
\&\f(CW\*(C`printf\*(C'\fR.
.Sp
.Vb 1
\&  print_uv( $val );
.Ve
.Sp
Output is sent to \s-1STDOUT.\s0
.IP "\fBprint_int\fR" 4
.IX Item "print_int"
Test that an \f(CW\*(C`int\*(C'\fR is formatted correctly by
\&\f(CW\*(C`printf\*(C'\fR.
.Sp
.Vb 1
\&  print_int( $val );
.Ve
.Sp
Output is sent to \s-1STDOUT.\s0
.IP "\fBprint_long\fR" 4
.IX Item "print_long"
Test that an \f(CW\*(C`long\*(C'\fR is formatted correctly by
\&\f(CW\*(C`printf\*(C'\fR.
.Sp
.Vb 1
\&  print_long( $val );
.Ve
.Sp
Output is sent to \s-1STDOUT.\s0
.IP "\fBprint_float\fR" 4
.IX Item "print_float"
Test that a single-precision floating point number is formatted
correctly by \f(CW\*(C`printf\*(C'\fR.
.Sp
.Vb 1
\&  print_float( $val );
.Ve
.Sp
Output is sent to \s-1STDOUT.\s0
.IP "\fBfilter\fR" 4
.IX Item "filter"
Installs a source filter that substitutes \*(L"e\*(R" for \*(L"o\*(R" (witheut regard fer
what it might be medifying).
.IP "\fBcall_sv\fR, \fBcall_pv\fR, \fBcall_method\fR" 4
.IX Item "call_sv, call_pv, call_method"
These exercise the C calls of the same names. Everything after the flags
arg is passed as the args to the called function. They return whatever
the C function itself pushed onto the stack, plus the return value from
the function; for example
.Sp
.Vb 4
\&    call_sv( sub { @_, \*(Aqc\*(Aq }, G_ARRAY,  \*(Aqa\*(Aq, \*(Aqb\*(Aq);
\&    # returns \*(Aqa\*(Aq, \*(Aqb\*(Aq, \*(Aqc\*(Aq, 3
\&    call_sv( sub { @_ },      G_SCALAR, \*(Aqa\*(Aq, \*(Aqb\*(Aq);
\&    # returns \*(Aqb\*(Aq, 1
.Ve
.IP "\fBeval_sv\fR" 4
.IX Item "eval_sv"
Evaluates the passed \s-1SV.\s0 Result handling is done the same as for
\&\f(CW\*(C`call_sv()\*(C'\fR etc.
.IP "\fBeval_pv\fR" 4
.IX Item "eval_pv"
Exercises the C function of the same name in scalar context. Returns the
same \s-1SV\s0 that the C function returns.
.IP "\fBrequire_pv\fR" 4
.IX Item "require_pv"
Exercises the C function of the same name. Returns nothing.
.SH "KEYWORDS"
.IX Header "KEYWORDS"
These are not supplied by default, but must be explicitly imported.
They are lexically scoped.
.IP "\s-1DEFSV\s0" 4
.IX Item "DEFSV"
Behaves like \f(CW$_\fR.
.IP "rpn(\s-1EXPRESSION\s0)" 4
.IX Item "rpn(EXPRESSION)"
This construct is a Perl expression.  \fI\s-1EXPRESSION\s0\fR must be an \s-1RPN\s0
arithmetic expression, as described below.  The \s-1RPN\s0 expression is
evaluated, and its value is returned as the value of the Perl expression.
.IP "calcrpn \s-1VARIABLE\s0 { \s-1EXPRESSION\s0 }" 4
.IX Item "calcrpn VARIABLE { EXPRESSION }"
This construct is a complete Perl statement.  (No semicolon should
follow the closing brace.)  \fI\s-1VARIABLE\s0\fR must be a Perl scalar \f(CW\*(C`my\*(C'\fR
variable, and \fI\s-1EXPRESSION\s0\fR must be an \s-1RPN\s0 arithmetic expression as
described below.  The \s-1RPN\s0 expression is evaluated, and its value is
assigned to the variable.
.SS "\s-1RPN\s0 expression syntax"
.IX Subsection "RPN expression syntax"
Tokens of an \s-1RPN\s0 expression may be separated by whitespace, but such
separation is usually not required.  It is required only where unseparated
tokens would look like a longer token.  For example, \f(CW\*(C`12 34 +\*(C'\fR can be
written as \f(CW\*(C`12 34+\*(C'\fR, but not as \f(CW\*(C`1234 +\*(C'\fR.
.PP
An \s-1RPN\s0 expression may be any of:
.ie n .IP "1234" 4
.el .IP "\f(CW1234\fR" 4
.IX Item "1234"
A sequence of digits is an unsigned decimal literal number.
.ie n .IP "$foo" 4
.el .IP "\f(CW$foo\fR" 4
.IX Item "$foo"
An alphanumeric name preceded by dollar sign refers to a Perl scalar
variable.  Only variables declared with \f(CW\*(C`my\*(C'\fR or \f(CW\*(C`state\*(C'\fR are supported.
If the variable's value is not a native integer, it will be converted
to an integer, by Perl's usual mechanisms, at the time it is evaluated.
.ie n .IP "\fIA\fR \fIB\fR ""+""" 4
.el .IP "\fIA\fR \fIB\fR \f(CW+\fR" 4
.IX Item "A B +"
Sum of \fIA\fR and \fIB\fR.
.ie n .IP "\fIA\fR \fIB\fR ""\-""" 4
.el .IP "\fIA\fR \fIB\fR \f(CW\-\fR" 4
.IX Item "A B -"
Difference of \fIA\fR and \fIB\fR, the result of subtracting \fIB\fR from \fIA\fR.
.ie n .IP "\fIA\fR \fIB\fR ""*""" 4
.el .IP "\fIA\fR \fIB\fR \f(CW*\fR" 4
.IX Item "A B *"
Product of \fIA\fR and \fIB\fR.
.ie n .IP "\fIA\fR \fIB\fR ""/""" 4
.el .IP "\fIA\fR \fIB\fR \f(CW/\fR" 4
.IX Item "A B /"
Quotient when \fIA\fR is divided by \fIB\fR, rounded towards zero.
Division by zero generates an exception.
.ie n .IP "\fIA\fR \fIB\fR ""%""" 4
.el .IP "\fIA\fR \fIB\fR \f(CW%\fR" 4
.IX Item "A B %"
Remainder when \fIA\fR is divided by \fIB\fR with the quotient rounded towards zero.
Division by zero generates an exception.
.PP
Because the arithmetic operators all have fixed arity and are postfixed,
there is no need for operator precedence, nor for a grouping operator
to override precedence.  This is half of the point of \s-1RPN.\s0
.PP
An \s-1RPN\s0 expression can also be interpreted in another way, as a sequence
of operations on a stack, one operation per token.  A literal or variable
token pushes a value onto the stack.  A binary operator pulls two items
off the stack, performs a calculation with them, and pushes the result
back onto the stack.  The stack starts out empty, and at the end of the
expression there must be exactly one value left on the stack.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
XS::Typemap, perlapi.
.SH "AUTHORS"
.IX Header "AUTHORS"
Tim Jenness, <t.jenness@jach.hawaii.edu>,
Christian Soeller, <csoelle@mph.auckland.ac.nz>,
Hugo van der Sanden <hv@crypt.compulink.co.uk>,
Andrew Main (Zefram) <zefram@fysh.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2002,2004 Tim Jenness, Christian Soeller, Hugo van der Sanden.
All Rights Reserved.
.PP
Copyright (C) 2009 Andrew Main (Zefram) <zefram@fysh.org>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
