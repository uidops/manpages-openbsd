.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "OpenBSD::style 3p"
.TH OpenBSD::style 3p "2020-12-20" "perl v5.32.1" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
OpenBSD::style \- Perl source file style guide
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This file specifies the preferred style for Perl source files
in the OpenBSD source tree.
.PP
The suggestions in \fBstyle\fR\|(9) also apply as far as they make sense
for Perl code and unless they are overridden in the present manual page.
.PP
Just as for \fBstyle\fR\|(9), indentation is an 8 character tab,
and statements continuing on the next line are indented
by four more spaces.
.SS "Subroutines and methods"
.IX Subsection "Subroutines and methods"
Prefer object-oriented over procedural style for new code.
Define a package under either \f(CW\*(C`OpenBSD::\*(C'\fR or \f(CW\*(C`DPB::\*(C'\fR.
If no state variables are needed, call methods directly on the class name.
Otherwise, define the state variables as member variables
and call methods on a constructed object.
Name the constructor \fBnew()\fR unless there are better options.
.PP
.Vb 2
\&        my $pkgpath = DPB::PkgPath\->new(\*(Aqdevel/quirks\*(Aq);
\&        say "Normalized version is ", $pkgpath\->fullpkgpath;
\&
\&        $state\->errsay(OpenBSD::Temp\->last_error);
.Ve
.PP
Inside methods, call the object \f(CW$self\fR unless there are reasons not to.
.PP
For functions with multiple parameters,
use list assignment to retrieve the arguments:
.PP
.Vb 5
\&        sub m3
\&        {
\&                my ($self, $p1, $p2) = @_;
\&                ...
\&        }
.Ve
.PP
Usually, there is no need to check the number of arguments.
.PP
For functions with exactly one parameter, one can alternatively
retrieve the argument with the \fBshift()\fR function:
.PP
.Vb 5
\&        sub width
\&        {
\&                my $self = shift;
\&                ...
\&        }
.Ve
.PP
Because it takes no argument apart from the object itself, calling
such a method doesn't need trailing empty parentheses:
.PP
.Vb 1
\&        my $columns = $object\->width;
.Ve
.PP
If a function passes on an arbitrary number of arguments
to another function:
.PP
.Vb 6
\&        sub wrapper_method
\&        {
\&                my $self = shift;
\&                ...
\&                do_something_with(@_);
\&        }
.Ve
.PP
Mark the last expression at the end of a function with an explicit
\&\fBreturn\fR unless the function is is not intended to return anything.
.PP
Avoid using the \fBwantarray()\fR function except as an optimization;
it should not change the semantics of the subroutine.
For example, suppose there is a function returning a list,
and while the question whether the list is empty sometimes
needs to be asked, the number of elements never matters.
Such a function can be structured and used as follows:
.PP
.Vb 9
\&        sub get_list
\&        {
\&                if (wantarray) {
\&                        # build the complete list and return it
\&                } else {
\&                        # only figure out whether the list is empty
\&                        # and return 0 if it is or 1 otherwise
\&                }
\&        }
\&
\&        if (get_list) {
\&                # do something that doesn\*(Aqt need the actual elements
\&        }
.Ve
.PP
Let methods that tweak an object return the object itself,
such that methods can be chained:
.PP
.Vb 1
\&        $object\->polish\->paint(\*(Aqblue\*(Aq)\->attach(@decorations);
.Ve
.PP
Since there are no access control restrictions in Perl,
simply mark internal methods by prefixing their names with \f(CW\*(C`_\*(C'\fR.
.PP
Treat anonymous subroutines just like other code,
indenting them by one tab:
.PP
.Vb 4
\&        my $s = sub {
\&                my $self = shift;
\&                ...
\&                };
.Ve
.PP
When passing an anonymous function as an argument, start it on a new line:
.PP
.Vb 5
\&        f($a1, $a2,
\&            sub {
\&                my $self = shift;
\&                ...
\&                });
.Ve
.SS "Files and packages"
.IX Subsection "Files and packages"
Putting several closely related classes
into the same source file is fine.
.PP
Avoid multiple inheritance unless absolutely necessary
because it almost always turns into a mess.
Including some behavior from a different class (mixin)
is best done on a per-method basis.
Delegating from one method of one class to a method of another class,
passing \f(CW@_\fR completely unchanged, can be done with the following syntax:
.PP
.Vb 1
\&        package Borrower;
\&
\&        sub visit_notary
\&        {
\&                &Lender::visit_notary;  # no parentheses here
\&        }
.Ve
.PP
If a program often uses \fBfork()\fR, set
.PP
.Vb 1
\&        $DB::inhibit_exit = 0;
.Ve
.PP
right after each \fBfork()\fR and before the following \fBexec()\fR,
such that a user trying to debug the main program isn't
prompted each time one of the child processes exits.
.SS "Data structures"
.IX Subsection "Data structures"
Autovivification is welcome:
.PP
.Vb 1
\&        push @{$self\->{list}}, $value;
.Ve
.PP
is fine without defining \f(CW\*(C`$self\->{list}\*(C'\fR first.
Note that
.PP
.Vb 1
\&        if (@{$self\->{list}} > 0)
.Ve
.PP
will not autovivify \f(CW\*(C`$self\->{list}\*(C'\fR,
so it can be used to check that the list exists and is not empty
without testing \f(CW\*(C`if (exists $self\->{list})\*(C'\fR first.
.PP
Don't put quotes around hash subscripts unless necessary;
they are not necessary for simple identifiers that are not keywords.
Avoid using keywords as hash keys.
.PP
Avoid needless arrows in chained lookups.
Rather than \f(CW\*(C`$self\->{a}\->{b}\*(C'\fR, write:
.PP
.Vb 1
\&        $self\->{a}{b}
.Ve
.SS "Syntax details"
.IX Subsection "Syntax details"
This style guide makes no recommendation to put parentheses
where they are not required.
For example, calling built-in or prototyped functions
does not require parentheses.
.PP
Modern Perl operators are preferred.
Rather than \f(CW\*(C`defined $value or $value = $something;\*(C'\fR
or \f(CW\*(C`$value = $something unless defined $value;\*(C'\fR, write:
.PP
.Vb 1
\&        $value //= $something;
.Ve
