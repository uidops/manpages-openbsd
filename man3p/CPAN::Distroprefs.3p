.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "CPAN::Distroprefs 3p"
.TH CPAN::Distroprefs 3p "2017-02-05" "perl v5.32.1" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
CPAN::Distroprefs \-\- read and match distroprefs
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use CPAN::Distroprefs;
\&
\&    my %info = (... distribution/environment info ...);
\&
\&    my $finder = CPAN::Distroprefs\->find($prefs_dir, \e%ext_map);
\&
\&    while (my $result = $finder\->next) {
\&
\&        die $result\->as_string if $result\->is_fatal;
\&
\&        warn($result\->as_string), next if $result\->is_warning;
\&
\&        for my $pref (@{ $result\->prefs }) {
\&            if ($pref\->matches(\e%info)) {
\&                return $pref;
\&            }
\&        }
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module encapsulates reading Distroprefs and matching them against \s-1CPAN\s0 distributions.
.SH "INTERFACE"
.IX Header "INTERFACE"
.Vb 1
\&    my $finder = CPAN::Distroprefs\->find($dir, \e%ext_map);
\&
\&    while (my $result = $finder\->next) { ... }
.Ve
.PP
Build an iterator which finds distroprefs files in the tree below the
given directory. Within the tree directories matching \f(CW\*(C`m/^[._]/\*(C'\fR are
pruned.
.PP
\&\f(CW%ext_map\fR is a hashref whose keys are file extensions and whose values are
modules used to load matching files:
.PP
.Vb 5
\&    {
\&        \*(Aqyml\*(Aq => \*(AqYAML::Syck\*(Aq,
\&        \*(Aqdd\*(Aq  => \*(AqData::Dumper\*(Aq,
\&        ...
\&    }
.Ve
.PP
Each time \f(CW\*(C`$finder\->next\*(C'\fR is called, the iterator returns one of two
possible values:
.IP "\(bu" 4
a CPAN::Distroprefs::Result object
.IP "\(bu" 4
\&\f(CW\*(C`undef\*(C'\fR, indicating that no prefs files remain to be found
.SH "RESULTS"
.IX Header "RESULTS"
\&\f(CW\*(C`find()\*(C'\fR returns CPAN::Distroprefs::Result objects to
indicate success or failure when reading a prefs file.
.SS "Common"
.IX Subsection "Common"
All results share some common attributes:
.PP
\fItype\fR
.IX Subsection "type"
.PP
\&\f(CW\*(C`success\*(C'\fR, \f(CW\*(C`warning\*(C'\fR, or \f(CW\*(C`fatal\*(C'\fR
.PP
\fIfile\fR
.IX Subsection "file"
.PP
the file from which these prefs were read, or to which this error refers (relative filename)
.PP
\fIext\fR
.IX Subsection "ext"
.PP
the file's extension, which determines how to load it
.PP
\fIdir\fR
.IX Subsection "dir"
.PP
the directory the file was read from
.PP
\fIabs\fR
.IX Subsection "abs"
.PP
the absolute path to the file
.SS "Errors"
.IX Subsection "Errors"
Error results (warning and fatal) contain:
.PP
\fImsg\fR
.IX Subsection "msg"
.PP
the error message (usually either \f(CW$!\fR or a \s-1YAML\s0 error)
.SS "Successes"
.IX Subsection "Successes"
Success results contain:
.PP
\fIprefs\fR
.IX Subsection "prefs"
.PP
an arrayref of CPAN::Distroprefs::Pref objects
.SH "PREFS"
.IX Header "PREFS"
CPAN::Distroprefs::Pref objects represent individual distroprefs documents.
They are constructed automatically as part of \f(CW\*(C`success\*(C'\fR results from \f(CW\*(C`find()\*(C'\fR.
.PP
\fIdata\fR
.IX Subsection "data"
.PP
the pref information as a hashref, suitable for e.g. passing to Kwalify
.PP
\fImatch_attributes\fR
.IX Subsection "match_attributes"
.PP
returns a list of the valid match attributes (see the Distroprefs section in \s-1CPAN\s0)
.PP
currently: \f(CW\*(C`env perl perlconfig distribution module\*(C'\fR
.PP
\fIhas_any_match\fR
.IX Subsection "has_any_match"
.PP
true if this pref has a 'match' attribute at all
.PP
\fIhas_valid_subkeys\fR
.IX Subsection "has_valid_subkeys"
.PP
true if this pref has a 'match' attribute and at least one valid match attribute
.PP
\fImatches\fR
.IX Subsection "matches"
.PP
.Vb 1
\&  if ($pref\->matches(\e%arg)) { ... }
.Ve
.PP
true if this pref matches the passed-in hashref, which must have a value for
each of the \f(CW\*(C`match_attributes\*(C'\fR (above)
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
