.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "O 3p"
.TH O 3p "2019-02-13" "perl v5.32.1" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
O \- Generic interface to Perl Compiler backends
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        perl \-MO=[\-q,]Backend[,OPTIONS] foo.pl
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the module that is used as a frontend to the Perl Compiler.
.PP
If you pass the \f(CW\*(C`\-q\*(C'\fR option to the module, then the \s-1STDOUT\s0
filehandle will be redirected into the variable \f(CW$O::BEGIN_output\fR
during compilation.  This has the effect that any output printed
to \s-1STDOUT\s0 by \s-1BEGIN\s0 blocks or use'd modules will be stored in this
variable rather than printed. It's useful with those backends which
produce output themselves (\f(CW\*(C`Deparse\*(C'\fR, \f(CW\*(C`Concise\*(C'\fR etc), so that
their output is not confused with that generated by the code
being compiled.
.PP
The \f(CW\*(C`\-qq\*(C'\fR option behaves like \f(CW\*(C`\-q\*(C'\fR, except that it also closes
\&\s-1STDERR\s0 after deparsing has finished. This suppresses the \*(L"Syntax \s-1OK\*(R"\s0
message normally produced by perl.
.SH "CONVENTIONS"
.IX Header "CONVENTIONS"
Most compiler backends use the following conventions: \s-1OPTIONS\s0
consists of a comma-separated list of words (no white-space).
The \f(CW\*(C`\-v\*(C'\fR option usually puts the backend into verbose mode.
The \f(CW\*(C`\-ofile\*(C'\fR option generates output to \fBfile\fR instead of
stdout. The \f(CW\*(C`\-D\*(C'\fR option followed by various letters turns on
various internal debugging flags. See the documentation for the
desired backend (named \f(CW\*(C`B::Backend\*(C'\fR for the example above) to
find out about that backend.
.SH "IMPLEMENTATION"
.IX Header "IMPLEMENTATION"
This section is only necessary for those who want to write a
compiler backend module that can be used via this module.
.PP
The command-line mentioned in the \s-1SYNOPSIS\s0 section corresponds to
the Perl code
.PP
.Vb 1
\&    use O ("Backend", OPTIONS);
.Ve
.PP
The \f(CW\*(C`O::import\*(C'\fR function loads the appropriate \f(CW\*(C`B::Backend\*(C'\fR module
and calls its \f(CW\*(C`compile\*(C'\fR function, passing it \s-1OPTIONS.\s0 That function
is expected to return a sub reference which we'll call \s-1CALLBACK.\s0 Next,
the \*(L"compile-only\*(R" flag is switched on (equivalent to the command-line
option \f(CW\*(C`\-c\*(C'\fR) and a \s-1CHECK\s0 block is registered which calls
\&\s-1CALLBACK.\s0 Thus the main Perl program mentioned on the command-line is
read in, parsed and compiled into internal syntax tree form. Since the
\&\f(CW\*(C`\-c\*(C'\fR flag is set, the program does not start running (excepting \s-1BEGIN\s0
blocks of course) but the \s-1CALLBACK\s0 function registered by the compiler
backend is called.
.PP
In summary, a compiler backend module should be called \*(L"B::Foo\*(R"
for some foo and live in the appropriate directory for that name.
It should define a function called \f(CW\*(C`compile\*(C'\fR. When the user types
.PP
.Vb 1
\&    perl \-MO=Foo,OPTIONS foo.pl
.Ve
.PP
that function is called and is passed those \s-1OPTIONS\s0 (split on
commas). It should return a sub ref to the main compilation function.
After the user's program is loaded and parsed, that returned sub ref
is invoked which can then go ahead and do the compilation, usually by
making use of the \f(CW\*(C`B\*(C'\fR module's functionality.
.SH "BUGS"
.IX Header "BUGS"
The \f(CW\*(C`\-q\*(C'\fR and \f(CW\*(C`\-qq\*(C'\fR options don't work correctly if perl isn't
compiled with PerlIO support : \s-1STDOUT\s0 will be closed instead of being
redirected to \f(CW$O::BEGIN_output\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
Malcolm Beattie, \f(CW\*(C`mbeattie@sable.ox.ac.uk\*(C'\fR
